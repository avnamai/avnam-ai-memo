import { LLMProvider } from '../llm-provider-api.js';

export class GeminiProvider extends LLMProvider {
    constructor(config = {}) {
        super(config);
        this.apiKey = null;
        this.baseUrl = config.baseUrl || 'https://generativelanguage.googleapis.com/v1';
        this.model = config.model || 'gemini-pro';
    }

    async initialize(apiKey) {
        if (!apiKey || typeof apiKey !== 'string' || apiKey.trim() === '') {
            throw new Error('Google AI API key is required');
        }

        if (!apiKey.startsWith('AIza')) {
            throw new Error('Invalid Google AI API key format. Google AI API keys start with "AIza"');
        }

        this.apiKey = apiKey;
        
        // Test connection by listing models
        try {
            await this.testConnection();
            this.initialized = true;
            return true;
        } catch (error) {
            throw new Error(`Google AI API authentication failed: ${error.message}`);
        }
    }

    async testConnection() {
        const response = await fetch(`${this.baseUrl}/models?key=${this.apiKey}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || `HTTP ${response.status}`);
        }

        return await response.json();
    }

    async chat(messages, options = {}) {
        if (!this.initialized) {
            throw new Error('Provider not initialized. Call initialize() first.');
        }

        // Convert messages to Gemini format
        const contents = this.formatMessagesForGemini(messages);

        const requestBody = {
            contents: contents,
            generationConfig: {
                temperature: options.temperature || 0.7,
                maxOutputTokens: options.max_tokens || 4096,
                topP: options.topP || 0.8,
                topK: options.topK || 40
            },
            safetySettings: options.safetySettings || this.getDefaultSafetySettings()
        };

        try {
            const response = await fetch(
                `${this.baseUrl}/models/${options.model || this.model}:generateContent?key=${this.apiKey}`,
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                }
            );

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `Google AI API error: HTTP ${response.status}`);
            }

            const data = await response.json();
            
            // Handle safety filtering
            if (data.candidates?.[0]?.finishReason === 'SAFETY') {
                throw new Error('Content was blocked by safety filters');
            }

            if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                throw new Error('No response generated by Gemini');
            }

            return {
                success: true,
                reply: data.candidates[0].content.parts[0].text,
                usage: {
                    prompt_tokens: data.usageMetadata?.promptTokenCount || 0,
                    completion_tokens: data.usageMetadata?.candidatesTokenCount || 0,
                    total_tokens: data.usageMetadata?.totalTokenCount || 0
                }
            };
        } catch (error) {
            throw error;
        }
    }

    async processMemo(content, options = {}) {
        if (!this.initialized) {
            throw new Error('Provider not initialized. Call initialize() first.');
        }

        // Sanitize content using inherited method
        const sanitizedContent = this.sanitizeContent(content);
        
        // Create system prompt for memo processing
        const systemPrompt = `You are an AI assistant that processes web content into structured memos. 
Extract key information from the provided HTML content and return a JSON object with the following structure:
{
    "title": "Main title or heading of the content",
    "summary": "A concise 2-3 sentence summary of the main points",
    "narrative": "A more detailed description of the content and its significance",
    "structuredData": {
        "key": "value pairs of important structured information"
    },
    "selectedTag": "A single relevant tag from: article, research, news, tutorial, reference, documentation, blog, social, product, company, person, event, other"
}

Return only valid JSON without any additional text or formatting.

Content to process:
${sanitizedContent}`;

        const messages = [
            { role: 'user', content: systemPrompt }
        ];

        try {
            const response = await this.chat(messages, {
                temperature: 0.3, // Lower temperature for more consistent structured output
                model: 'gemini-pro', // Use standard model for text processing
                ...options
            });

            let parsedResponse;
            try {
                parsedResponse = JSON.parse(response.reply);
            } catch (parseError) {
                throw new Error('Failed to parse Gemini response as JSON');
            }

            // Validate required fields
            const requiredFields = ['title', 'summary', 'narrative', 'structuredData', 'selectedTag'];
            for (const field of requiredFields) {
                if (!(field in parsedResponse)) {
                    parsedResponse[field] = field === 'structuredData' ? {} : '';
                }
            }

            return parsedResponse;
        } catch (error) {
            throw error;
        }
    }

    formatMessagesForGemini(messages) {
        const contents = [];
        
        for (const message of messages) {
            // Convert role format
            const role = message.role === 'assistant' ? 'model' : 'user';
            
            contents.push({
                role: role,
                parts: [{ text: message.content }]
            });
        }
        
        return contents;
    }

    calculateTokens(text) {
        if (!text || typeof text !== 'string') {
            return 0;
        }

        // Gemini models use roughly 4 characters per token (similar to GPT)
        // This is an approximation - for exact counting, would need Gemini's tokenizer
        const avgCharsPerToken = 4;
        return Math.ceil(text.length / avgCharsPerToken);
    }

    getAvailableModels() {
        return [
            'gemini-pro',
            'gemini-pro-vision',
            'gemini-1.5-pro',
            'gemini-1.5-flash'
        ];
    }

    getProviderInfo() {
        return {
            id: 'gemini',
            name: 'Google Gemini',
            description: 'Gemini AI models by Google',
            requiresApiKey: true,
            models: this.getAvailableModels(),
            supportsVision: true,
            supportsSystemMessages: false // Gemini doesn't have explicit system messages
        };
    }

    validateConfig(config) {
        if (!config || typeof config !== 'object') {
            return false;
        }

        // Check if config is empty object
        if (Object.keys(config).length === 0) {
            return false;
        }

        // Check API key format
        if (!config.apiKey || typeof config.apiKey !== 'string' || !config.apiKey.startsWith('AIza')) {
            return false;
        }

        // Check model if provided
        if (config.model && !this.getAvailableModels().includes(config.model)) {
            return false;
        }

        return true;
    }

    getDefaultSafetySettings() {
        return [
            {
                category: 'HARM_CATEGORY_HARASSMENT',
                threshold: 'BLOCK_MEDIUM_AND_ABOVE'
            },
            {
                category: 'HARM_CATEGORY_HATE_SPEECH',
                threshold: 'BLOCK_MEDIUM_AND_ABOVE'
            },
            {
                category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
                threshold: 'BLOCK_MEDIUM_AND_ABOVE'
            },
            {
                category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
                threshold: 'BLOCK_MEDIUM_AND_ABOVE'
            }
        ];
    }

    getSafetySettings(level = 'BLOCK_MEDIUM_AND_ABOVE') {
        const categories = [
            'HARM_CATEGORY_HARASSMENT',
            'HARM_CATEGORY_HATE_SPEECH',
            'HARM_CATEGORY_SEXUALLY_EXPLICIT',
            'HARM_CATEGORY_DANGEROUS_CONTENT'
        ];

        return categories.map(category => ({
            category: category,
            threshold: level
        }));
    }

    getGenerationConfig(options = {}) {
        return {
            temperature: options.temperature || 0.7,
            maxOutputTokens: options.maxTokens || 4096,
            topP: options.topP || 0.8,
            topK: options.topK || 40,
            candidateCount: 1 // Gemini currently only supports 1
        };
    }
}